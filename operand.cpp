#include "operand.hpp"
#include <algorithm>
#include <cmath>
#include "exceptions.hpp"

// this function should be auto generated by the compiler.
int operand::get_precision(void) const { return (int)_type; }

// hey look another dumb fuck function that should be implied.
optype operand::get_type(void) const { return _type; }

// why do we have to write these functions
std::string const &operand::to_string(void) const { return _string; }

// should these be macros?
operand::operand(std::string string, optype type)
    : _string(string), _type(type) {}

// now we do the operators. none of this is interesting it's just a bunch of
// conversions and bullshit. the only cool part of it is promoting ints to
// floats or doubles and correctly stoll or stold-ing the 'strings'.
// these should all probably be macros.

void operand::operator=(const operand &rhs) {
  _string = rhs.to_string();
  _type = rhs.get_type();
}

ioperand const *operand::operator+(ioperand const &rhs) const {
  optype outop = std::max(_type, rhs.get_type());
  std::string outstr;
  operand_factory factory;

  // if outop is <= int32 then we stoll it. otherwise we need to stold or it
  // will break for some ungodly reason.
  if (outop <= optype::Int32) {
    long long a = std::stoll(to_string());
    long long b = std::stoll(rhs.to_string());
    outstr = std::to_string(a + b);
  } else {
    long double a = std::stold(to_string());
    long double b = std::stold(rhs.to_string());
    outstr = std::to_string(a + b);
  }
  return factory.create_operand(outstr, outop);
}

ioperand const *operand::operator-(ioperand const &rhs) const {
  optype outop = std::max(_type, rhs.get_type());
  std::string outstr;
  operand_factory factory;

  // if outop is <= int32 then we stoll it. otherwise we need to stold or it
  // will break for some ungodly reason.
  if (outop <= optype::Int32) {
    long long a = std::stoll(to_string());
    long long b = std::stoll(rhs.to_string());
    outstr = std::to_string(a - b);
  } else {
    long double a = std::stold(to_string());
    long double b = std::stold(rhs.to_string());
    outstr = std::to_string(a - b);
  }
  return factory.create_operand(outstr, outop);
}

ioperand const *operand::operator*(ioperand const &rhs) const {
  optype outop = std::max(_type, rhs.get_type());
  std::string outstr;
  operand_factory factory;

  // if outop is <= int32 then we stoll it. otherwise we need to stold or it
  // will break for some ungodly reason.
  if (outop <= optype::Int32) {
    long long a = std::stoll(to_string());
    long long b = std::stoll(rhs.to_string());
    outstr = std::to_string(a * b);
  } else {
    long double a = std::stold(to_string());
    long double b = std::stold(rhs.to_string());
    outstr = std::to_string(a * b);
  }
  return factory.create_operand(outstr, outop);
}

ioperand const *operand::operator/(ioperand const &rhs) const {
  optype outop = std::max(_type, rhs.get_type());
  std::string outstr;
  operand_factory factory;

  // if outop is <= int32 then we stoll it. otherwise we need to stold or it
  // will break for some ungodly reason.
  if (outop <= optype::Int32) {
    long long a = std::stoll(to_string());
    long long b = std::stoll(rhs.to_string());
    if (b == 0) throw division_by_zero();
    outstr = std::to_string(a / b);
  } else {
    long double a = std::stold(to_string());
    long double b = std::stold(rhs.to_string());
    if (b == 0) throw division_by_zero();
    outstr = std::to_string(a / b);
  }
  return factory.create_operand(outstr, outop);
}

ioperand const *operand::operator%(ioperand const &rhs) const {
  optype outop = std::max(_type, rhs.get_type());
  std::string outstr;
  operand_factory factory;

  // if outop is <= int32 then we stoll it. otherwise we need to stold or it
  // will break for some ungodly reason.
  if (outop <= optype::Int32) {
    long long a = std::stoll(to_string());
    long long b = std::stoll(rhs.to_string());
    if (b == 0) throw division_by_zero();
    outstr = std::to_string(a % b);
  } else {
    long double a = std::stold(to_string());
    long double b = std::stold(rhs.to_string());
    if (b == 0) throw division_by_zero();
    outstr = std::to_string(std::fmod(a, b));
  }
  return factory.create_operand(outstr, outop);
}

// now we make the dumb fuck operand factory shit for no good reason fuck you.
ioperand const *operand_factory::create_operand(std::string const &value,
                                                optype type) const {
  switch (type) {
    case optype::Int8:
      return create_int8(value);
      break;
    case optype::Int16:
      return create_int16(value);
      break;
    case optype::Int32:
      return create_int32(value);
      break;
    case optype::Float:
      return create_float(value);
      break;
    case optype::Double:
      return create_double(value);
      break;
    default:
      throw unknown_instruction("unknown operand type");
  }
}

// creat int8 dawg.
ioperand const *operand_factory::create_int8(std::string const &value) const {
  long long int num = std::stoll(value);
  if (num > std::numeric_limits<char>().max()) throw overflow_int8();
  if (num < std::numeric_limits<char>().lowest()) throw underflow_int8();
  return new operand(value, optype::Int8);
}

// creat int16 dawg.
ioperand const *operand_factory::create_int16(std::string const &value) const {
  long long int num = std::stoll(value);
  if (num > std::numeric_limits<short>().max()) throw overflow_int16();
  if (num < std::numeric_limits<short>().lowest()) throw underflow_int16();
  return new operand(value, optype::Int16);
}

// creat int32 dawg.
ioperand const *operand_factory::create_int32(std::string const &value) const {
  long long int num = std::stoll(value);
  if (num > std::numeric_limits<int>().max()) throw overflow_int32();
  if (num < std::numeric_limits<int>().lowest()) throw underflow_int32();
  return new operand(value, optype::Int32);
}

// creat float dawg.
ioperand const *operand_factory::create_float(std::string const &value) const {
  std::stof(value);
  return new operand(value, optype::Float);
}

// creat double dawg.
ioperand const *operand_factory::create_double(std::string const &value) const {
  std::stod(value);
  return new operand(value, optype::Double);
}
